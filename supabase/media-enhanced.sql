-- Enhanced Media Storage Schema for Production\n-- Run this after the main schema to add media-specific enhancements\n\n-- Add missing columns to media table\nALTER TABLE media ADD COLUMN IF NOT EXISTS content_hash TEXT;\nALTER TABLE media ADD COLUMN IF NOT EXISTS whatsapp_sha256 TEXT;\nALTER TABLE media ADD COLUMN IF NOT EXISTS bucket_name TEXT;\nALTER TABLE media ADD COLUMN IF NOT EXISTS processed BOOLEAN DEFAULT FALSE;\nALTER TABLE media ADD COLUMN IF NOT EXISTS processing_error TEXT;\nALTER TABLE media ADD COLUMN IF NOT EXISTS processing_attempts INTEGER DEFAULT 0;\nALTER TABLE media ADD COLUMN IF NOT EXISTS last_accessed_at TIMESTAMPTZ;\n\n-- Add indexes for media queries\nCREATE INDEX IF NOT EXISTS idx_media_content_hash ON media(content_hash);\nCREATE INDEX IF NOT EXISTS idx_media_whatsapp_sha256 ON media(whatsapp_sha256);\nCREATE INDEX IF NOT EXISTS idx_media_bucket_name ON media(bucket_name);\nCREATE INDEX IF NOT EXISTS idx_media_processed ON media(processed);\nCREATE INDEX IF NOT EXISTS idx_media_message_id ON media(message_id);\nCREATE INDEX IF NOT EXISTS idx_media_created_at ON media(created_at DESC);\n\n-- Add constraints\nALTER TABLE media ADD CONSTRAINT IF NOT EXISTS chk_media_file_size CHECK (file_size > 0 AND file_size <= 52428800); -- 50MB limit\nALTER TABLE media ADD CONSTRAINT IF NOT EXISTS chk_media_bucket_name CHECK (bucket_name IN ('images', 'audio', 'videos', 'documents'));\n\n-- Media processing queue table for async processing\nCREATE TABLE IF NOT EXISTS media_processing_queue (\n  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,\n  message_id UUID REFERENCES messages(id) ON DELETE CASCADE,\n  whatsapp_media_id TEXT NOT NULL,\n  media_type TEXT NOT NULL CHECK (media_type IN ('image', 'audio', 'video', 'document')),\n  priority INTEGER DEFAULT 5 CHECK (priority >= 1 AND priority <= 10),\n  status TEXT DEFAULT 'pending' CHECK (status IN ('pending', 'processing', 'completed', 'failed')),\n  attempts INTEGER DEFAULT 0,\n  max_attempts INTEGER DEFAULT 3,\n  error_message TEXT,\n  scheduled_at TIMESTAMPTZ DEFAULT NOW(),\n  started_at TIMESTAMPTZ,\n  completed_at TIMESTAMPTZ,\n  created_at TIMESTAMPTZ DEFAULT NOW(),\n  updated_at TIMESTAMPTZ DEFAULT NOW()\n);\n\n-- Indexes for processing queue\nCREATE INDEX IF NOT EXISTS idx_media_queue_status ON media_processing_queue(status);\nCREATE INDEX IF NOT EXISTS idx_media_queue_priority ON media_processing_queue(priority DESC, created_at ASC);\nCREATE INDEX IF NOT EXISTS idx_media_queue_scheduled ON media_processing_queue(scheduled_at) WHERE status = 'pending';\nCREATE INDEX IF NOT EXISTS idx_media_queue_message_id ON media_processing_queue(message_id);\n\n-- Media analytics table\nCREATE TABLE IF NOT EXISTS media_analytics (\n  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,\n  date DATE DEFAULT CURRENT_DATE,\n  media_type TEXT NOT NULL,\n  bucket_name TEXT NOT NULL,\n  total_files INTEGER DEFAULT 0,\n  total_size_bytes BIGINT DEFAULT 0,\n  successful_uploads INTEGER DEFAULT 0,\n  failed_uploads INTEGER DEFAULT 0,\n  avg_processing_time_ms INTEGER DEFAULT 0,\n  created_at TIMESTAMPTZ DEFAULT NOW(),\n  updated_at TIMESTAMPTZ DEFAULT NOW(),\n  UNIQUE(date, media_type, bucket_name)\n);\n\n-- Indexes for analytics\nCREATE INDEX IF NOT EXISTS idx_media_analytics_date ON media_analytics(date DESC);\nCREATE INDEX IF NOT EXISTS idx_media_analytics_type ON media_analytics(media_type);\n\n-- Update trigger for media_processing_queue\nCREATE OR REPLACE FUNCTION update_media_queue_updated_at()\nRETURNS TRIGGER AS $$\nBEGIN\n  NEW.updated_at = NOW();\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER update_media_queue_updated_at\n  BEFORE UPDATE ON media_processing_queue\n  FOR EACH ROW\n  EXECUTE FUNCTION update_media_queue_updated_at();\n\n-- Function to clean up old media files\nCREATE OR REPLACE FUNCTION cleanup_old_media(days_old INTEGER DEFAULT 90)\nRETURNS INTEGER AS $$\nDECLARE\n  deleted_count INTEGER;\nBEGIN\n  -- Delete media records older than specified days with no recent access\n  DELETE FROM media \n  WHERE created_at < NOW() - INTERVAL '1 day' * days_old\n    AND (last_accessed_at IS NULL OR last_accessed_at < NOW() - INTERVAL '1 day' * (days_old / 2));\n  \n  GET DIAGNOSTICS deleted_count = ROW_COUNT;\n  \n  RETURN deleted_count;\nEND;\n$$ LANGUAGE plpgsql SECURITY DEFINER;\n\n-- Function to get media storage statistics\nCREATE OR REPLACE FUNCTION get_media_storage_stats()\nRETURNS JSON AS $$\nDECLARE\n  result JSON;\nBEGIN\n  SELECT json_build_object(\n    'total_files', COUNT(*),\n    'total_size_mb', ROUND(SUM(file_size)::numeric / 1024 / 1024, 2),\n    'by_type', (\n      SELECT json_object_agg(media_type, stats)\n      FROM (\n        SELECT \n          media_type,\n          json_build_object(\n            'count', COUNT(*),\n            'size_mb', ROUND(SUM(file_size)::numeric / 1024 / 1024, 2),\n            'avg_size_kb', ROUND(AVG(file_size)::numeric / 1024, 2)\n          ) as stats\n        FROM media\n        WHERE processed = true\n        GROUP BY media_type\n      ) t\n    ),\n    'by_bucket', (\n      SELECT json_object_agg(bucket_name, stats)\n      FROM (\n        SELECT \n          bucket_name,\n          json_build_object(\n            'count', COUNT(*),\n            'size_mb', ROUND(SUM(file_size)::numeric / 1024 / 1024, 2)\n          ) as stats\n        FROM media\n        WHERE processed = true AND bucket_name IS NOT NULL\n        GROUP BY bucket_name\n      ) t\n    ),\n    'processing_stats', (\n      SELECT json_build_object(\n        'processed', COUNT(*) FILTER (WHERE processed = true),\n        'failed', COUNT(*) FILTER (WHERE processed = false AND processing_error IS NOT NULL),\n        'pending', COUNT(*) FILTER (WHERE processed = false AND processing_error IS NULL)\n      )\n      FROM media\n    )\n  ) INTO result\n  FROM media\n  WHERE processed = true;\n  \n  RETURN result;\nEND;\n$$ LANGUAGE plpgsql SECURITY DEFINER;\n\n-- Function to queue media for processing\nCREATE OR REPLACE FUNCTION queue_media_processing(\n  p_message_id UUID,\n  p_whatsapp_media_id TEXT,\n  p_media_type TEXT,\n  p_priority INTEGER DEFAULT 5\n)\nRETURNS UUID AS $$\nDECLARE\n  queue_id UUID;\nBEGIN\n  INSERT INTO media_processing_queue (\n    message_id,\n    whatsapp_media_id,\n    media_type,\n    priority\n  ) VALUES (\n    p_message_id,\n    p_whatsapp_media_id,\n    p_media_type,\n    p_priority\n  )\n  RETURNING id INTO queue_id;\n  \n  RETURN queue_id;\nEND;\n$$ LANGUAGE plpgsql SECURITY DEFINER;\n\n-- RLS policies for media tables\nALTER TABLE media_processing_queue ENABLE ROW LEVEL SECURITY;\nALTER TABLE media_analytics ENABLE ROW LEVEL SECURITY;\n\n-- Admin access to media processing queue\nCREATE POLICY \"Admin manage media queue\" ON media_processing_queue\n  FOR ALL USING (check_admin_role('content_admin'));\n\n-- Admin access to media analytics\nCREATE POLICY \"Admin view media analytics\" ON media_analytics\n  FOR SELECT USING (check_admin_role('moderator'));\n\nCREATE POLICY \"Admin manage media analytics\" ON media_analytics\n  FOR ALL USING (check_admin_role('content_admin'));\n\n-- Comments for documentation\nCOMMENT ON TABLE media_processing_queue IS 'Queue for asynchronous media processing';\nCOMMENT ON TABLE media_analytics IS 'Daily analytics for media storage and processing';\nCOMMENT ON FUNCTION cleanup_old_media(INTEGER) IS 'Clean up old media files to manage storage usage';\nCOMMENT ON FUNCTION get_media_storage_stats() IS 'Get comprehensive media storage statistics';\nCOMMENT ON FUNCTION queue_media_processing(UUID, TEXT, TEXT, INTEGER) IS 'Queue media for asynchronous processing';\n\n-- Insert initial analytics record\nINSERT INTO media_analytics (date, media_type, bucket_name, total_files, total_size_bytes)\nSELECT \n  CURRENT_DATE,\n  'image',\n  'images',\n  0,\n  0\nON CONFLICT (date, media_type, bucket_name) DO NOTHING;\n\nINSERT INTO media_analytics (date, media_type, bucket_name, total_files, total_size_bytes)\nSELECT \n  CURRENT_DATE,\n  'audio',\n  'audio',\n  0,\n  0\nON CONFLICT (date, media_type, bucket_name) DO NOTHING;\n\nINSERT INTO media_analytics (date, media_type, bucket_name, total_files, total_size_bytes)\nSELECT \n  CURRENT_DATE,\n  'video',\n  'videos',\n  0,\n  0\nON CONFLICT (date, media_type, bucket_name) DO NOTHING;\n\nINSERT INTO media_analytics (date, media_type, bucket_name, total_files, total_size_bytes)\nSELECT \n  CURRENT_DATE,\n  'document',\n  'documents',\n  0,\n  0\nON CONFLICT (date, media_type, bucket_name) DO NOTHING;